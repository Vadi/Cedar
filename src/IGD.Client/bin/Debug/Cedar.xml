<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Cedar</name>
    </assembly>
    <members>
        <member name="T:Cedar.Sharding.ShardStrategy.ShardSelection.ShardSelectionStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cedar.Sharding.ShardStrategy.ShardSelection.ShardSelectionStrategy.SelectShardIdForNewObject(Cedar.ShardStartegyData)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Cedar.Sharding.ShardStrategy.ShardSelection.ShardSelectionStrategy.SelectShardIdForExistingObject(Cedar.ShardStartegyData)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Cedar.Sharding.ShardStrategy.ShardSelection.ShardSelectionStrategy.GetSequentialStrategy(System.Int64,System.Collections.Generic.IList{Cedar.ShardWile})">
            <summary>
            
            </summary>
            <param name="shardId"></param>
            <returns></returns>
        </member>
        <member name="T:Cedar.CedarAppStore">
            <summary>
            Initiates Cedar Application
            </summary>
            <remarks>
            There should be only one instance for this class across the application lifecycle. This class follows singleton pattern
            to provide single instance approach
            </remarks>
        </member>
        <member name="T:Cedar.Sharding.ShardStrategy.ShardStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="T:Cedar.Sharding.ShardStrategy.IShardStrategy">
             <summary>
            
             </summary>
        </member>
        <member name="P:Cedar.Sharding.ShardStrategy.IShardStrategy.ShardSelectionStrategy">
             <summary>
            
             </summary>
        </member>
        <member name="P:Cedar.Sharding.ShardStrategy.IShardStrategy.ShardResolutionStrategy">
             <summary>
            
             </summary>
        </member>
        <member name="P:Cedar.Sharding.ShardStrategy.IShardStrategy.ShardAccessStrategy">
             <summary>
            
             </summary>
        </member>
        <member name="P:Cedar.Sharding.ShardStrategy.ShardStrategy.ShardSelectionStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cedar.IdWorker.#ctor(System.Int64,System.Func{System.Int64})">
            <summary>
            
            </summary>
            <param name="shardId"></param>
            <param name="timeMaker"></param>
        </member>
        <member name="M:Cedar.IdWorker.SetBeginSequence(System.Int64)">
            <summary>
            
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Cedar.IdWorker.GetUniqueId">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cedar.IdWorker.DecomposeKey(System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Cedar.IdWorker.CreateDecomposeMask">
            <summary>
            creates a masks for extracting 10 bit of shard.
            </summary>
        </member>
        <member name="M:Cedar.IdWorker.TillNextMillis(System.Int64)">
            <summary>
            
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="P:Cedar.IdWorker.ShardId">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cedar.IdWorker.CurrentTimestampInMs">
            <summary>
            
            </summary>
        </member>
        <member name="T:Cedar.IdWorker.TimeMakerWithLocalTime">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cedar.Utility.DecomposeKey(System.Int64)">
            <summary>
            returns Shardid
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cedar.ShardStrategyRepository.GetShardStrategy">
            <summary>
            Get all shard strategy
            </summary>
            <returns></returns>
        </member>
        <member name="T:Dapper.SqlMapper">
            <summary>
            Dapper, a light weight object mapper for ADO.NET
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.PurgeQueryCache">
            <summary>
            Purge the query cache 
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.GetCachedSQLCount">
            <summary>
            Return a count of all the cached queries by dapper
            </summary>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GetCachedSQL(System.Int32)">
            <summary>
            Return a list of all the queries cached by dapper
            </summary>
            <param name="ignoreHitCountAbove"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GetHashCollissions">
            <summary>
            Deep diagnostics only: find any hash collisions in the cache
            </summary>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Execute(System.Data.IDbConnection,System.String,System.Object,System.Data.IDbTransaction,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Execute parameterized SQL  
            </summary>
            <returns>Number of rows affected</returns>
        </member>
        <member name="M:Dapper.SqlMapper.Query(System.Data.IDbConnection,System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Return a list of dynamic objects, reader is closed after the call
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.Query``1(System.Data.IDbConnection,System.String,System.Object,System.Data.IDbTransaction,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Executes a query, returning the data typed as per T
            </summary>
            <remarks>the dynamic param may seem a bit odd, but this works around a major usability issue in vs, if it is Object vs completion gets annoying. Eg type new [space] get new object</remarks>
            <returns>A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column in assumed, otherwise an instance is
            created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
            </returns>
        </member>
        <member name="M:Dapper.SqlMapper.QueryMultiple(System.Data.IDbConnection,System.String,System.Object,System.Data.IDbTransaction,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Execute a command that returns multiple result sets, and access each in turn
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.QueryInternal``1(System.Data.IDbConnection,System.String,System.Object,System.Data.IDbTransaction,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Return a typed list of objects, reader is closed after the call
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.Query``3(System.Data.IDbConnection,System.String,System.Func{``0,``1,``2},System.Object,System.Data.IDbTransaction,System.Boolean,System.String,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Maps a query to objects
            </summary>
            <typeparam name="TFirst">The first type in the recordset</typeparam>
            <typeparam name="TSecond">The second type in the recordset</typeparam>
            <typeparam name="TReturn">The return type</typeparam>
            <param name="cnn"></param>
            <param name="sql"></param>
            <param name="map"></param>
            <param name="param"></param>
            <param name="transaction"></param>
            <param name="buffered"></param>
            <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
            <param name="commandTimeout">Number of seconds before command execution timeout</param>
            <param name="commandType">Is it a stored proc or a batch?</param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Query``4(System.Data.IDbConnection,System.String,System.Func{``0,``1,``2,``3},System.Object,System.Data.IDbTransaction,System.Boolean,System.String,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Maps a query to objects
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="cnn"></param>
            <param name="sql"></param>
            <param name="map"></param>
            <param name="param"></param>
            <param name="transaction"></param>
            <param name="buffered"></param>
            <param name="splitOn">The Field we should split and read the second object from (default: id)</param>
            <param name="commandTimeout">Number of seconds before command execution timeout</param>
            <param name="commandType"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Query``5(System.Data.IDbConnection,System.String,System.Func{``0,``1,``2,``3,``4},System.Object,System.Data.IDbTransaction,System.Boolean,System.String,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Perform a multi mapping query with 4 input parameters
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TFourth"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="cnn"></param>
            <param name="sql"></param>
            <param name="map"></param>
            <param name="param"></param>
            <param name="transaction"></param>
            <param name="buffered"></param>
            <param name="splitOn"></param>
            <param name="commandTimeout"></param>
            <param name="commandType"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Query``6(System.Data.IDbConnection,System.String,System.Func{``0,``1,``2,``3,``4,``5},System.Object,System.Data.IDbTransaction,System.Boolean,System.String,System.Nullable{System.Int32},System.Nullable{System.Data.CommandType})">
            <summary>
            Perform a multi mapping query with 5 input parameters
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TFourth"></typeparam>
            <typeparam name="TFifth"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="cnn"></param>
            <param name="sql"></param>
            <param name="map"></param>
            <param name="param"></param>
            <param name="transaction"></param>
            <param name="buffered"></param>
            <param name="splitOn"></param>
            <param name="commandTimeout"></param>
            <param name="commandType"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.ReadChar(System.Object)">
            <summary>
            Internal use only
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.ReadNullableChar(System.Object)">
            <summary>
            Internal use only
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.PackListParameters(System.Data.IDbCommand,System.String,System.Object)">
            <summary>
            Internal use only
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.CreateParamInfoGenerator(Dapper.SqlMapper.Identity)">
            <summary>
            Internal use only
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.GetTypeDeserializer(System.Type,System.Data.IDataReader,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Internal use only
            </summary>
            <param name="type"></param>
            <param name="reader"></param>
            <param name="startBound"></param>
            <param name="length"></param>
            <param name="returnNullIfFirstMissing"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.ThrowDataException(System.Exception,System.Int32,System.Data.IDataReader)">
            <summary>
            Throws a data exception, only used internally
            </summary>
            <param name="ex"></param>
            <param name="index"></param>
            <param name="reader"></param>
        </member>
        <member name="E:Dapper.SqlMapper.QueryCachePurged">
            <summary>
            Called if the query cache is purged via PurgeQueryCache
            </summary>
        </member>
        <member name="T:Dapper.SqlMapper.IDynamicParameters">
            <summary>
            Implement this interface to pass an arbitrary db specific set of parameters to Dapper
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.IDynamicParameters.AddParameters(System.Data.IDbCommand,Dapper.SqlMapper.Identity)">
            <summary>
            Add all the parameters needed to the command just before it executes
            </summary>
            <param name="command">The raw command prior to execution</param>
            <param name="identity">Information about the query</param>
        </member>
        <member name="T:Dapper.SqlMapper.Link`2">
            <summary>
            This is a micro-cache; suitable when the number of terms is controllable (a few hundred, for example),
            and strictly append-only; you cannot change existing values. All key matches are on **REFERENCE**
            equality. The type is fully thread-safe.
            </summary>
        </member>
        <member name="T:Dapper.SqlMapper.Identity">
            <summary>
            Identity of a cached query in Dapper, used for extensability
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.Identity.ForDynamicParameters(System.Type)">
            <summary>
            Create an identity for use with DynamicParameters, internal use only
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Identity.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.sql">
            <summary>
            The sql
            </summary>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.commandType">
            <summary>
            The command type 
            </summary>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.hashCode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.gridIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.connectionString">
            <summary>
            
            </summary>
        </member>
        <member name="F:Dapper.SqlMapper.Identity.parametersType">
            <summary>
            
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.Identity.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.Identity.Equals(Dapper.SqlMapper.Identity)">
            <summary>
            Compare 2 Identity objects
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Dapper.SqlMapper.GridReader">
            <summary>
            The grid reader provides interfaces for reading multiple result sets from a Dapper query 
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Read``1">
            <summary>
            Read the next grid of results
            </summary>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Read``3(System.Func{``0,``1,``2},System.String)">
            <summary>
            Read multiple objects from a single recordset on the grid
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="func"></param>
            <param name="splitOn"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Read``4(System.Func{``0,``1,``2,``3},System.String)">
            <summary>
            Read multiple objects from a single recordset on the grid
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="func"></param>
            <param name="splitOn"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Read``5(System.Func{``0,``1,``2,``3,``4},System.String)">
            <summary>
            Read multiple objects from a single record set on the grid
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TFourth"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="func"></param>
            <param name="splitOn"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Read``6(System.Func{``0,``1,``2,``3,``4,``5},System.String)">
            <summary>
            Read multiple objects from a single record set on the grid
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
            <typeparam name="TFourth"></typeparam>
            <typeparam name="TFifth"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="func"></param>
            <param name="splitOn"></param>
            <returns></returns>
        </member>
        <member name="M:Dapper.SqlMapper.GridReader.Dispose">
            <summary>
            Dispose the grid, closing and disposing both the underlying reader and command.
            </summary>
        </member>
        <member name="T:Dapper.DynamicParameters">
            <summary>
            A bag of parameters that can be passed to the Dapper Query and Execute methods
            </summary>
        </member>
        <member name="M:Dapper.DynamicParameters.#ctor">
            <summary>
            construct a dynamic parameter bag
            </summary>
        </member>
        <member name="M:Dapper.DynamicParameters.#ctor(System.Object)">
            <summary>
            construct a dynamic parameter bag
            </summary>
            <param name="template">can be an anonymous type of a DynamicParameters bag</param>
        </member>
        <member name="M:Dapper.DynamicParameters.AddDynamicParams(System.Object)">
            <summary>
            Append a whole object full of params to the dynamic
            EG: AddParams(new {A = 1, B = 2}) // will add property A and B to the dynamic
            </summary>
            <param name="param"></param>
        </member>
        <member name="M:Dapper.DynamicParameters.Add(System.String,System.Object,System.Nullable{System.Data.DbType},System.Nullable{System.Data.ParameterDirection},System.Nullable{System.Int32})">
            <summary>
            Add a parameter to this dynamic parameter list
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="dbType"></param>
            <param name="direction"></param>
            <param name="size"></param>
        </member>
        <member name="M:Dapper.DynamicParameters.Get``1(System.String)">
            <summary>
            Get the value of a parameter
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns>The value, note DBNull.Value is not returned, instead the value is returned as null</returns>
        </member>
        <member name="P:Dapper.DynamicParameters.ParameterNames">
            <summary>
            All the names of the param in the bag, use Get to yank them out
            </summary>
        </member>
        <member name="T:Dapper.DbString">
            <summary>
            This class represents a SQL string, it can be used if you need to denote your parameter is a Char vs VarChar vs nVarChar vs nChar
            </summary>
        </member>
        <member name="M:Dapper.DbString.#ctor">
            <summary>
            Create a new DbString
            </summary>
        </member>
        <member name="M:Dapper.DbString.AddParameter(System.Data.IDbCommand,System.String)">
            <summary>
            Add the parameter to the command... internal use only
            </summary>
            <param name="command"></param>
            <param name="name"></param>
        </member>
        <member name="P:Dapper.DbString.IsAnsi">
            <summary>
            Ansi vs Unicode 
            </summary>
        </member>
        <member name="P:Dapper.DbString.IsFixedLength">
            <summary>
            Fixed length 
            </summary>
        </member>
        <member name="P:Dapper.DbString.Length">
            <summary>
            Length of the string -1 for max
            </summary>
        </member>
        <member name="P:Dapper.DbString.Value">
            <summary>
            The value of the string
            </summary>
        </member>
        <member name="T:Cedar.Sharding.ShardStrategy.Strategy">
             <summary>
            
             </summary>
        </member>
        <member name="F:Cedar.Sharding.ShardStrategy.Strategy.Sequential">
             <summary>
            
             </summary>
        </member>
        <member name="F:Cedar.Sharding.ShardStrategy.Strategy.Regional">
             <summary>
            
             </summary>
        </member>
        <member name="T:Cedar.ShardStartegyData">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cedar.ShardStartegyData.StrategyType">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cedar.ShardStartegyData.Region">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cedar.ShardStartegyData.App">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cedar.ICedar.SetupSchema">
            <summary>
            set up the scehma first time, it returns the key to the app
            </summary>
            <param name="appName"></param>
            <returns></returns>
        </member>
        <member name="M:Cedar.CedarSession.Close">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="M:Cedar.CedarSession.Insert(System.String,System.Object,System.Nullable{Cedar.CommandType})">
            <summary>
            Execute the query 
            </summary>
            <param name="sql"></param>
            <param name="param"></param>
            <param name="commandType"></param>
            <returns>>Number of rows affected</returns>
        </member>
        <member name="T:Cedar.AppContext">
            <summary>
            This class provides session object to deal with your sharded databases
            </summary>
        </member>
        <member name="M:Cedar.AppContext.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="appName"></param>
        </member>
        <member name="M:Cedar.AppContext.SetupSchema(Cedar.ShardStartegyData)">
            <summary>
            this method will set up schema for new user, will return unique id to application
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cedar.AppContext.GetSession(System.Int64)">
             <summary>
            
             </summary>
             <param name="uuid"></param>
             <returns></returns>
        </member>
        <member name="P:Cedar.AppContext.App">
             <summary>
            
             </summary>
        </member>
        <member name="P:Cedar.AppContext.ShardStrategy">
            <summary>
            get and set the shard strategy, if not set default startegy will be set.
            </summary>
        </member>
    </members>
</doc>
